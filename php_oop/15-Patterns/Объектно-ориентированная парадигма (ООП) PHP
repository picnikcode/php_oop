Объектно-ориентированная парадигма (ООП) PHP


Основа ООП:
1. Классы и их объекты (экземпляры классов)
2. Свойства классов (переменные с модификатором в классах)
3. Методы классов (функции с модификаторами в классах)
4. Конструкторы и деструкторы в классах (магические методы)
5. Константы в классах (const, как статическое свойство)
6. Статические свойства и методы (контекст класса)
7. Наследование (extends)
8. Модификаторы доступа (public/protected/private)
9. Абстрактные классы(невозможно создать объект) и интерфейсы(те же классы, но без реализации)
10. Контроль типа через интерфейс(тип класса = тип интерфейса)
11. Автозагрузка классов(не используя require_once()) и пространство имен
12. Composer и автозагрузка 
13. Трейты
14. Позднее статическое связывание
15. Магические методы(зарезервированные методы PHP)
16. Шаблоны проектирования

Свойства/атрибуты/поля - это переменные в классе!
Методы - это функции в классе!

Модификаторы доступа - это public/private/protected  (они приписываются к каждому свойству и методу!)

Классы используются через объекты класса (экземпляры класса):
class Test { public $name #code }
$Obj = new Test(); - Obj  является объектом класса 

Обращаться к свойствам и методам нужно через созданный объект класса:
$Obj->name; - Вернет значение свойства «$name» (также и с методами)

Чтобы пользоваться свойствами и методами в самом классе используется псевдопеременная $this (данная переменная говорит о том, что используется данные объект), пример:

class Test{
	public $name;

	public function getName(){
		$this->name; // Ей можно присваивать и делать что угодно
	}
}

В классах реализованы «магические методы» одни из самы требуемых это метод ы __construct() и __destruct() (конструктор и деструктор) - они вызываются автоматический, когда был создан объект класса и когда объект был удален из память соответственно (__destruct() выполняет код в самый последний момент), примеры:

class Test{
	public function __construct($arguments){
	     //Выполняет код первым делом при объявлении объекта!
	    //Также метод может содержать аргументы!
	}

	public function __destruct(){
		// выполняет код в самом конце(перед удалением объекта из памяти(автоматически))
	}
}

При этом, чтобы отдать аргументы конструктору (__construct()) требуется указать их при объявлении объекта класса, в котором реализован конструктор! Пример:

$Obj = new Test(«Аргумента»); // «Аргумента» отдастца в метод __construct()

Также свойства и методы могут быть статическими! Пример объявления статического свойства и метода:

public static $name;

public static function $Test(){

}

Для работы с статическими свойствами и методами ВНУТРИ класса используется не объектный контекст, а классовы! ($this->$name НЕ ИСПОЛЬЗУЕТСЯ при статике, также и с методом!) 

При этом используется специальный оператор sellf и :: 
Пример:

 public static $name;

public static function Test(){
	self::$name; 
// $ - ставить обязательно! (Это работа с статическими свойствами)
}

При использовании статического метода внутри класса делается точно также как и со свойствами! Пример:

self::Test();

При классовом контексте (статике), свойства и методы ВНЕ класса объявляются  без объекта! А использует классовый контекст! Пример:

$name1 = NameClass::$name (или метод)

В обычном методе можно работать со свойствами статического типа! Но в статическом методе работать с НЕ статическими свойствами нельзя!!!

Константы в классе объявляются через слово const! Пример:

const NAME = «Nik»;  // Не требуется ставить знак $!

Константы в классе являются статическим свойством и при их вызове также не требуется объект (если вызов идет из вне класса)! Пример использования:

В классе (классовый контекст): 

public function test(){
	$a = self::NAME; // Также  не ставится знак $
	// Передача в переменную $a значение из константы NAME
}

 Вне класса (классовый контекст):

$a = NameClass::NAME; // Также  не ставится знак $
// Передача в переменную $a значение из константы NAME из класса NameClass!

Наследование позволяет определенному классу унаследовать код из другого класса. Наследование происходит с помощью ключевого слова «extends»
 Пример:

class Test1 {
	public $name = «Nik»;
	public function test(){}
}

class Test2 extends Test1{
	echo $name; // Вывод «Nik»
	
	parent::test; - Вызовет метод из родительского класса!
}

Модификаторы доступа - нужны для контроля доступа (контроля кода)!

Public доступен везде! (в классе, в наследовательских классах, вне класса!)

	public $public = "PUBLIC"; 

Protected доступен исключительно в классе и классах наследования (ВНЕ класса не доступен!)

	protected $protected = "PROTECTED";

Private доступен только в том классе где он объявлен! (Вне класса и в классах наследниках он не доступен!)

	private $private = "PRIVATE";

Для доступа любого свойства не зависимо от типа модификатор используются геттеры(получают значение из свойства) и сеттеры(задают значение свойству)

Они должны объявляться строго в том классе, где расположены свойства!
Примеры:

// Геттер
	public function getDiscount(): int // ": int" Контроль возвращаемого типа 
	{
		return $this->discount;
	}

// Сеттер
	public function setDiscount(int $discount){ //  "int" Контроль типа входных данных
		$this->discount = $discount;
	}



—Абстрактные классы—

Абстрактные классы созданы для того, что бы нельзя было создавать их экземпляр (объект класса)! (Зона видимости)
С абстрактными классами работают исключительно через наследование!
Пример:

abstract class Product 
{

}

Также в абстрактных классах можно определять абстрактные методы (исключительно в абстрактных классах!) но при определении абстрактного метода нельзя использовать данные метод, он не должен иметь даже тела функции! 
Пример:

abstract class Product 
{
	abstract protected function addProduct($name, $price);
}	

Работать с абстрактными методами возможно только в дочернем классе (относительно абстрактного класса), а точнее его необходимо там инициализировать!
Пример:

abstract class Product 
{
	abstract protected function addProduct($name, $price);
}	


class Book extends Product // Book - дочерний класс (наследник)
{
	public function addProduct($name, $price $test = 0){
	
	}
}

Если в абстрактном классе объявлен абстрактный метод, то его необходимо инициализировать и в дочернем классе вместе с телом и теми же параметрами(аргументами), иначе будет ошибка!!!

Модификатор доступа у инициализированного абстрактного метода (в дочернем классе) может быть ниже чем при объвлении абстрактного метода в родительном классе, если задан абстрактный протектед метод, то инициализировать в дочернем классе мы его можем только protected или public (как в данном примере) private нельзя (уровень доступа выше!), если был бы public в родительном классе, то никакой другой поставить было бы нельзя! 

Количесво параметров(аргументов) должно совпадать с объявленным абсрактным методом в родительном классе! Но если требуется добавить параметры(аргументы), то их нужно сделать не обязательными(присвоить значение  как в примере выше)! 

Со статическими методами и свойствами можно работать и в абстрактных классах!

—Интерфейсы—

Интерфейсы - это те же классы, только без реализации (как абстрактный метод в абстрактном классе!)

Все методы должны быть публичными!!!

Интерфейсы не могут содержать свойства, но могут содержать константы(const)!
Пример:

interface test {

	const TEST = "Test intarface";

	public function test(); // Методы не должны иметь тело {}!

}

Ключевое слово подключения «implements»

Все константы работают в контексте класса, а не объекта!
Пример подключение интерфейса:

class Book extends Product implements test 
{
	// Обязательное объявление метода из интерфейса!!!
	public function test(){ 
		echo «self::TEST»; // вывод константы из интерфейса!
	}
}

Также в дочерних классах константы можно переопределять! Например, родительном классе объявлена константа (в данном классе переопределять константу нельзя!), но в дочернем классе (при наследовании) возможно переопределять константы, которы были заданы в родительном классе, просто их объявлять теми же именами и ставить другое значение!!!

Но константы в интерфейсах переопределять нельзя (из инициализированных методов в классе, к которому был подключен интерфейс)!

—Контроль типа—

Чаще всего интерфейсы применяются с контролем типом, а именно, с помощью интерфейса, объект (экземпляр класса) с подключенным интерфейсом получает уникальный тип (интерфейс). И по данному типу можно контролировать входные параметры функции, либо условие.
Пример: 

interface test {

	public function test(); // Методы не должны иметь тело {}!

}

class Book extends Product implements test 
{
	// Обязательное объявление метода из интерфейса!!!
	public function test(){ 
		
	}
	
	// Контроль типа через интерфейс!
	public function offerCase(test $product){  // test - это строгая типизация
		echo "Ноутбук {$product->getName()}";
	}	
	
	public function code(){
		offerCase($this);
	}
}

В вышеуказанном примере, в методе offerCase(test $product) задана жесткая типизация, то есть входной параметр в метод должен быть исключительно типом «test» другие типы данных не пройдут в метод!

При подключении интерфейса к классу, класс имеет доступ к его типу! То есть, класс Book имеет типы Book, Product, а также test, так как подключен интерфейс, и данный класс один имеет такой тип!!!

Для проверки к какому типу относится объект создана следующая конструкция с ключевым словом «instanceof»:

$obj - объект, test - проверяемый класс
var_dump($obj instanceof test); // Выводит результат в булевом типе(true/false)

Например был создан объект класса Book:

$book = new Book();

Проверим его отношение к типам:

var_dump($book instanceof test); // true
var_dump($book instanceof book); // true
var_dump($book instanceof Product); // true

var_dump($book instanceof Notebook); // false

Как видно из примера выше, наследуемый класс принимает все типы его родителей, а также всех подключенных интерфейсов!

И по данным типам можно реализовывать методы/функции со строгим типом входных параметров или строить условия относительно типам входных данных!

—Автозагрузка—-

Автозагрузка нужна для того, что бы не писать много require_once() Более старая версия автозагрузки классов - __autoload()

Автозагрузка используется с помощью специальной функции «spl_autoload_register("autoloader1»)», где в аргументы функции передается наименование функции, которая подключает файлы!

Данную функцию автозагрузки классов можно вызовыть сколько угодно!

Также  доступны еще  2 параметра в данной функции, которые задают приоритетность очередности вызова функции, если стоит два параметра true, то данная функция вызовится первее чем другая!

Пример использования автозагрузки:

function autoloader1($class){
		$file = $class . ".php";
		if(file_exists($file)){ // Проверка на существование файла
			require_once($file);
		}
	}

spl_autoload_register("autoloader"); 

Вышеуказанный код подключает все используемые файлы с классами!

Пространство имен нужно для того, что бы классы могли называться одинаково(относительно пространств имен), а также для поиска пути при автозагрузки!
Пространство имен нужно для путей к файлам классов
Пространство имен задается ключевым словом: 

namespace /classes/;
	class Test {

	}

При использовании пространства имен, имя класса изменяется!

Пространство имён используют с автозагрузкой классов (пути для классов/интерфейсов и тд) 

—-Компосер—-

Компосер - менеджер подключаемых пакетов  (через данную технологию можно автоматический скачивать пакеты/библиотеки)

Через компосер можно использовать автозагрузку пространств имен!!!
Компосер работает с определенными файлами в формате .json 
Пример правил:

{
	"require": {
		"phpmailer/phpmailer": "^6.0" // Правила, что скачивать!
	}, 
	"autoload":{
		"psr-4":{ 
			      Если увидел папку        -     То качай в эту папку!
			"11-Autoload_Composer\\": "11-Autoload_Composer"
		} 
	}
}

PSR-4 - это стандарт написания кода (где брекеты, скобки ставятся и тд )

ПОСМОТРЕТЬ УРОКИ ПРО ПРОСТРАНСТВО ИМЕН!

ИЗУЧИТЬ КОМПОСЕР!

——Трейты——

Трейты - это те же интерфейсы, от которых нельзя создать объект, но они имеют реализацию! Трейты могут подключаться к любому классу и не присваивают тип к подключенному классу!

Трейты нужны для того, что бы не копировать код! Например, есть интернет магазин, в нем продаются товары, у которых цвет это как характеристика, а есть товары, которых цвет бессмысленно описывать  (книга), создав трейт и описав в нем цвет, мы можем обращать к нему и задавать/получать цвет (подключив трейт к определенному классу(классу товара))!

Пример:


trait TColor{ // Создание трейта

	private $color;	

	public function setColor($color_){
		$this->color = $color_;
	}

	public function getColor(){
		return $this->color;
	}

}

// Подключение трейта к классу

require_once("trait.php"); // Подключаем фаил 

class Notebook extends Product{
	
	use TColor; // Подключили к классу трейт!
	
	(Как будто тут скопирован код из трейта!)
	
	
}

——Вне класса (index.php)——

$notebook = new Notebook(); // Создали объект класса

$notebook->setColor(«Red»); // Задали цвет, который хранится в трейте

echo ($notebook->getColor()); // Вывели цвет из трейта

Работать с трейтами исключительно через объект класса, к которому подключён трейт! (В контексте объекта)


——Позднее статическое связывание——

Позднее статическое связывание нужно для того что бы обращаться к переопределенному статическому свойству в классе наследнике (уменьшает код)

Ключевое слово (замена self::) на static::

Пример:

class A{

	protected const TEST = "Class A";

	public function getTest(){
		var_dump(self::TEST); // self - указывает на тот класс, где определенно свойство(переменная)!
	}

	public function getTest2(){

		var_dump(static::TEST); 

static::NameAtribute - позволяет работать с атрибутом в том классе, в котором сейчас работаем!
static - указывает на то свойсво, с которым мы работаем!
	}

}

class B extends A{

	const TEST = "Class B";

}

При обращении к объекту класса B и вывода метода getTest2() - выводится «Class B», то есть константа переопределится в дочернем классе B;

$a = new A(); // создаем объекты классов
$b = new B();

	$a->getTest(); // "Class A"
	$b->getTest(); // «Class A"
	echo "<hr>";
	$b->getTest2(); // "Class B» (потому что использовался static::)

—Цепочка методов—

$a = new A(); // создаем объект класса

$a ->Method1()->Method2(); // Цепочка классов

Цепочки методов очень удобны и популярны в фрэймворках!

Что бы цепочка работала, в каждом методе нужно возвращать объект класса(return $this;)

Также в цепочке можно работать с методами других  классов, для этого нужно в классе определить объект другого класса и в методе возвращать этот самый объект и можно будет работать с методами другого класса, который мы определили!

————————

—-Магические методы—-

Рассмотренные магические методы:
__toString()
__get($name)
__set($name,$value)

 Когда пытаемся приобразовать(отобразить) объект в(как) строку, то срабатывает метод __toString()

 Если требуется что то отправлять при выводе через echo/print_r объект класса, то необходим магический метод __toString();

Пример:

Вне класса

$book = new bookProduct();

echo $book->getProduct();

echo $book; // Отобразит инфу о товаре (идентично строке выше!)

В классе

 class bookProduct(){
	public function __toString(){
		return $this->getProduct();  // Возвращает информацию о товаре!
	}
}

Если были вызваны неопределенные свойства класса (вне класса), то его имя передастся в аргументу $name, магического метода __get()

Пример:

Вне класса

$book = new bookProduct();
echo $book->name; // Вызов неопределенного свойства класса

В данном случае $book->name вызовет метод getName() в классе bookProduct и отобразит имя товара (хоть и свойство было неопределенным в классе)

В классе

class bookProduct{
	public function __get($name){
		var_dump($name);
		$name = ucfirst($name);
		$method = "get{$name}";
		if(method_exists($this, $method)){
			return $this->$method();
		}
method_exists(object, NameMethod)  - проверяет, есть ли метод в данном класса (через объект)
	}
}

Если были заданы свойства классу вне класса и им присвоены значения, то мы можем их получить в магическом методе __set($name, $value)!

Магический метод __set($name, $value) - отображает неопределенные свойства объекта (которые были опеределены вне класса)

Пример

Вне класса

$book = new bookProduct();
$book->test = "Hello";	// Добавить свойство в объект класса! (Неопределенное свойство)

С помощью магического метода __set() - вместо ошибки будут выведены имя и значение неопределенного свойства(в классе)!

В классе

class bookProduct{
	public function __set($name, $value){
		var_dump($name,$value); // Отображает имя неопределенного свойства и его значение! 
	}
}

—Шаблоны(паттерны) проектирования—

Ссылка на паттерны проектирование: 
[https://designpatternsphp.readthedocs.io/ru/latest/README.html]

Паттерны проектирования нужны для того, что бы решить распространенную проблему не придумывая велосипед!

Например, требуется класс для подключения БД, его нужно определить единожды и больше не давать возможности определять (запретить создание больше 1 объекта класса DB)
  
Для этого создан паттерн Singleton!

class DB{
	
	// Паттерн синглтон используется для того, что бы нельзя было создать более 1 объекта класса!

	private static $instance; // Статическое свойство позволяет не перегружать свойство повторно

	protected function __construct(){

	}

	public static function getInstance(){
		if(self::$instance === null){
			self::$instance = new self(); // Присваиваем объект класса
		}
		return self::$instance; // Возвращаем объект класса 
	}

	// ——————
	
	private static $connect;	

	public static function connecting($nameDB){
		if(self::$connect === null){
			self::$connect = $nameDB;
		}
		return self::$connect;
	}

}

Вне класса

$A = DB::getInstance(); // Создаем разные объекты
$B = DB::getInstance();

var_dump($A); // Получаем объект А
echo "<br>";
var_dump($B); // Получаем объект А!

echo $test1 = DB::connecting("Diplom"); // Вывод Diplom
echo $test2 = DB::connecting("Shablon"); // Вывод Diplom 

echo $A->connecting(«Top»); // Аналогичный вызов метода, через статический объект!